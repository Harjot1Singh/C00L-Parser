program         ::= class;
                | class; program

class           ::= class TYPE { classFeature }
                | class TYPE { }
                | class TYPE inherits TYPE { classFeature }
                | class TYPE inherits TYPE { }

classFeature    ::= feature;
                | feature; classFeature

feature         ::= ID( featureFormal ) : TYPE { expr }
                | ID( ) : TYPE { expr }
                | ID : TYPE <- expr
                | ID : TYPE

featureFormal   ::= formal
                | formal, featureFormal

formal          ::= ID : TYPE

expr            ::= expr@TYPE.ID( exprComma )
                | expr@TYPE.ID( )
                | expr.ID( exprComma )
                | expr.ID( )
                | ID( exprComma )
                | ID( )
                | if expr then expr else expr fi
                | while expr loop expr pool
                | { exprSemiColon }
                | let IDTypeExprs in expr
                | case expr of IDTypeArrow esac
                | new TYPE
                | (expr)
                | assignTerm

IDTypeArrow     ::= ID : TYPE => expr;
                | ID : TYPE => expr; IDTypeArrow

IDTypeExprs     ::= IDTypeExpr
                | IDTypeExpr, IDTypeExprs

IDTypeExpr      ::= ID : TYPE
                | ID : TYPE <- expr

exprComma       ::= expr
                | expr, exprComma

exprSemiColon   ::= expr;
                | expr; exprSemiColon

assignTerm      ::= ID <-  notTerm
                | notTerm

notTerm         ::= not compareTerm
                | compareTerm

compareTerm     ::= addTerm compareTerm'

compareTerm'    ::= <= addTerm compareTerm'
                | < addTerm compareTerm'
                | = addTerm compareTerm'
                | ϵ

addTerm         ::= multiTerm addTerm'

addTerm'        ::= + multiTerm addTerm'
                | - multiTerm addTerm'
                | ϵ

multiTerm       ::= isvoidTerm multiTerm'

multiTerm'      ::= * isvoidTerm multiTerm'
                | / isvoidTerm multiTerm'
                | ϵ

isvoidTerm      ::= isvoid tildeTerm
                | tildeTerm

tildeTerm       ::= ~factor
                | factor

factor          ::= ID
                | integer
                | string
                | true
                | false

TODO: Left factoring, left recursion removal